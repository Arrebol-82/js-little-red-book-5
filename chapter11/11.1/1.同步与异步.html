<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="../../index.css">
</head>

<body>
  <h1>同步与异步</h1>
  <section>
    <h2>同步行为</h2>
    <p><strong>同步行为</strong> 对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序执行，而每条令执行后也能立即获得存储在系统本地(如寄存器或系统内存)的信息
      <strong>也就是会按照代码书写顺序执行 , 而且随时能拿到前面步骤的结果</strong> , 这样的执行流程容易分析程序在执行到代码任意位置的状态 (比如变量的值)
    </p>
    <p class="retract">同步操作的例子可以是执行一次简单的数学计算: </p>
    <code>
      <pre>
        let x = 3
        x = x + 4
      </pre>
    </code>
    <p>在程序执行的每一步 , 都可以推断出程序的状态。这是因为后面的指令总是在前面的指令完成后才会执行。等到最后一条指令执行完毕，存储在x的值就立即可以使用。</p>
    <p class="retract">这两行 JavaScript代码对应的低级指令(从JavaScript到x86)并不难想象 首先,操作系统会在栈内存上分配一个存储浮点数值的空间 ,
      然后针对这个值做一次数学计算，再把计算结果写回之前分配的内存中。所有这些指令都是在单个线程中按顺序执行的。在低级指令的层面，有充足的工具可以确定系统状态。</p>
    <p>这段话解释强调了同步操作在底层的执行特点</p>
    <ul>
      <li class="circle">顺序性：指令按代码顺序依次执行。</li>
      <li class="circle">确定性：每个步骤的系统状态可精确预测。</li>
      <li class="circle">单线程：所有操作在同一个线程内完成，不涉及线程间通信。</li>
    </ul>
  </section>
  <section>
    <h2>异步行为</h2>
    <p><strong>异步行为</strong> 类似于系统中断，即当前进程外部的实体可以触发代码执行。<strong>程序（进程）自己没主动执行代码，但外面的 “东西” 能让它的代码跑起来。</strong>
      异步操作经常是必要的，因为强制进程等待一个长时间的操作通常是不可行的(同步操作则必须要等)。 如果代码要访问些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待。</p>
    <p class="retract">异步操作的例子可以是在定时回调中执行一次简单的数学计算:</p>
    <code>
      <pre>
      let y = 4
      setTimeout(() => y = y + 4, 1000)  // 4
      setTimeout(() => console.log(y), 2000) // 8
      </pre>
    </code>
    <p>这段程序最终与同步代码执行的任务一样,都是把两个数加在一起，但这一次执行线程不知道x值
      何时会改变，因为这取决于回调何时从消息队列出队并执行。</p>
    <p>异步代码不容易推断。虽然这个例子对应的低级代码最终跟前面的例子没什么区别，但第二个指令块(加操作及赋值操作)是由 <strong>系统计时器触发的</strong>，
      这会生成一个人队执行的中断。到底什么时候会触发这个中断，这对JavaScript运行时来说是一个黑盒，因此实际上无法预知 (尽管可以保证这发生在当前线程的同步代码执行之后，否则回调都没有机会出队被执行)
      无论如何，在排定回调以后基本没办法知道系统状态何时变化。 <strong>大白话就是: 异步代码一定等同步代码跑完才会执行，但具体什么时候执行完（返回结果），没法精确控制。</strong></p>
    <p class="retreat">为了让后续代码能够使用x，异步执行的函数需要在更新x的值以后通知其他代码。如果程序不需要这个值 , 那么就只管继续执行 , 不必等待这个结果 <strong>说白了就是要的话就拿取用 ,
        如果是不需要的那就继续执行, 垃圾回收机制会回收它</strong></p>
    <p>设计一个能够知道x什么时候可以读取的系统是非常难的。JavaScript在实现这样一个系统的过程中也经历了几次迭代。</p>
  </section>
  <script>
    let x = 3
    x = x + 4

    let y = 4
    setTimeout(() => y = y + 4, 1000)
    setTimeout(() => console.log(y), 2000)
  </script>
</body>

</html>