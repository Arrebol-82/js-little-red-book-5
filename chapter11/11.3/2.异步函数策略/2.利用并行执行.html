<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="../../../index.css">
</head>

<body>
  <h1>利用并行执行</h1>
  <p>如果使用 await 时不留心 , 则很可能错过并行加速的机会 , 来看下面的例子 , 其中顺序等待了5个随机的超时</p>
  <code>
    <pre>
    async function randomDelay(id) {
      // 延迟 0 ~ 1000 毫秒
      const delay = Math.random() * 1000
      return new Promise((resolve) => setTimeout(() => {
        console.log(`${id} finished`);
        resolve()
      }, delay))
    }

    async function foo() {
      const t0 = Date.now()
      await randomDelay(0)
      await randomDelay(1)
      await randomDelay(2)
      await randomDelay(3)
      await randomDelay(4)
      console.log(`${Date.now() - t0}ms elapsed`)
    }
    foo()

    <strong>这段代码也是同理 , 运行5次 ,然后每次的延迟时间随机 , 等待上一次成功返回 , 才会执行下一次</strong>
    </pre>
  </code>
  <p>用一个for循环重写, 就是</p>
  <code>
    <pre>
    async function RandomDelay(id) {
      // 延迟 0 ~ 1000 毫秒
      const delay = Math.random() * 1000
      return new Promise((resolve) => setTimeout(() => {
        console.log(`${id} finished`)
        resolve()
      }, delay))
    }

    async function Foo() {
      const t0 = Date.now()
      for (let i = 0; i < 5; ++i) {
        await RandomDelay(i)
      }
      console.log(`${Date.now() - t0}ms elapsed`);
    }
    Foo()
    </pre>
  </code>
  <p>就算这些期约之间没有依赖,异步函数也会依次暂停,等待每个超时完成。这样可以保证执行顺序 , 但总执行时间会变长
    如果顺序不是保证的 , 那么可以先一次性初始化所有期约,然后再分别等待它们的结果。比如:</p>
  <code>
      <pre>
    async function randomDelay(id) {
      // 延迟0 ~ 1000 毫秒
      const delay = Math.random() * 1000;
      return new Promise((resolve) => setTimeout(() => {
        console.asyncLog(`${id} finished`)
        resolve()
      }, delay))
    }

    async function foo() {
      const t0 = Date.now()

      const p0 = randomDelay(0)
      const p1 = randomDelay(1)
      const p2 = randomDelay(2)
      const p3 = randomDelay(3)
      const p4 = randomDelay(4)

      await p0
      await p1
      await p2
      await p3
      await p4
      console.asyncLog(`${Date.now() - t0} ms elapesd`)
    }

    foo()

    2 finished
    4 finished
    3 finished
    0 finished
    1 finished
    849 ms elapesd
      </pre>
    </code>
  <p>要记住 在const p0 = randomDela(0)的时候 , 已经执行了里面的代码了 , 而await只是拖长了时间 , 让date.now输出的值更直观</p>
  <p>用数组 和 for 循环再包装一下就是:</p>
  <code>
    <pre>
    async function randomDelay(id) {
      // 延迟 0 ~ 1000 毫秒
      const delay = Math.random() * 1000
      return new Promise((resolve) => setTimeout(() => {
        console.log(`${id} finished`)
        resolve()
      }, delay))
    }

    async function foo() {
      const t0 = Date.now()
      const Promises = Array(5).fill(null).map((_, i) => randomDelay(i))

      for (const p of Promises) {
        await p
      }
      console.log(`${Date.now() - t0}ms elapsed`)
    }
    foo()

    <strong>这里的 map(_) 就是用来占位的 , 为的就是使用第二个元素 , 也就是索引</strong>
    </pre>
  </code>
  <p>注意，虽然期约没有按照顺序执行，但await按顺序收到了每个兑现期约的值:</p>
  <code>
    <pre>
  async function randomDelay(id) {
      // 延迟 0 ~ 1000 毫秒
      const delay = Math.random() * 1000
      return new Promise((resolve) => setTimeout(() => {
        console.log(`${id} finished`)
        resolve(id)
      }, delay))
    }

    async function foo() {
      const t0 = Date.now()
      const Promises = Array(5).fill(null).map((_, i) => randomDelay(i))

      for (const p of Promises) {
        console.log(`awaited ${await p}`)
      }
      console.log(`${Date.now() - t0}ms elapsed`)
    }
    foo()

    // 0 finished
    // awaited 0
    // 2 finished
    // 3 finished
    // 4 finished
    // 1 finished
    // awaited 1
    // awaited 2
    // awaited 3
    // awaited 4
    // 871ms elapsed
    </pre>
  </code>
  <p>虽然执行的时间不一样的 , 但是await的输出顺序是不会变的</p>
  <script>
    console.asyncLog = (...residue) => setTimeout(console.log, 0, ...residue)

    // async function randomDelay(id) {
    //   // 延迟 0 ~ 1000 毫秒
    //   const delay = Math.random() * 1000
    //   return new Promise((resolve) => setTimeout(() => {
    //     console.log(`${id} finished`);
    //     resolve()
    //   }, delay))
    // }

    // async function foo() {
    //   const t0 = Date.now()
    //   await randomDelay(0)
    //   await randomDelay(1)
    //   await randomDelay(2)
    //   await randomDelay(3)
    //   await randomDelay(4)
    //   console.log(`${Date.now() - t0}ms elapsed`)
    // }
    // // foo()

    // // 用for循环重写

    // async function RandomDelay(id) {
    //   // 延迟 0 ~ 1000 毫秒
    //   const delay = Math.random() * 1000
    //   return new Promise((resolve) => setTimeout(() => {
    //     console.log(`${id} finished`)
    //     resolve()
    //   }, delay))
    // }

    // async function Foo() {
    //   const t0 = Date.now()
    //   for (let i = 0; i < 5; ++i) {
    //     await RandomDelay(i)
    //   }
    //   console.log(`${Date.now() - t0}ms elapsed`);
    // }
    // Foo()

    // async function randomDelay(id) {
    //   // 延迟0 ~ 1000 毫秒
    //   const delay = Math.random() * 1000;
    //   return new Promise((resolve) => setTimeout(() => {
    //     console.asyncLog(`${id} finished`)
    //     resolve()
    //   }, delay))
    // }

    // async function foo() {
    //   const t0 = Date.now()

    //   const p0 = randomDelay(0)
    //   const p1 = randomDelay(1)
    //   const p2 = randomDelay(2)
    //   const p3 = randomDelay(3)
    //   const p4 = randomDelay(4)

    //   await p0
    //   await p1
    //   await p2
    //   await p3
    //   await p4
    //   console.asyncLog(`${Date.now() - t0} ms elapesd`)
    // }

    // foo()

    // async function randomDelay(id) {
    //   // 延迟 0 ~ 1000 毫秒
    //   const delay = Math.random() * 1000
    //   return new Promise((resolve) => setTimeout(() => {
    //     console.log(`${id} finished`)
    //     resolve()
    //   }, delay))
    // }

    // async function foo() {
    //   const t0 = Date.now()
    //   const Promises = Array(5).fill(null).map((_, i) => randomDelay(i))

    //   for (const p of Promises) {
    //     await p
    //   }
    //   console.log(`${Date.now() - t0}ms elapsed`)
    // }
    // foo()

    async function randomDelay(id) {
      // 延迟 0 ~ 1000 毫秒
      const delay = Math.random() * 1000
      return new Promise((resolve) => setTimeout(() => {
        console.log(`${id} finished`)
        resolve(id)
      }, delay))
    }

    async function foo() {
      const t0 = Date.now()
      const Promises = Array(5).fill(null).map((_, i) => randomDelay(i))

      for (const p of Promises) {
        console.log(`awaited ${await p}`)
      }
      console.log(`${Date.now() - t0}ms elapsed`)
    }
    foo()

    // 0 finished
    // awaited 0
    // 2 finished
    // 3 finished
    // 4 finished
    // 1 finished
    // awaited 1
    // awaited 2
    // awaited 3
    // awaited 4
    // 871ms elapsed


  </script>
</body>

</html>