<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <h1>使用Promise.race()</h1>
  <p>Promise.race()静态方法返回一个包装期约 , 是一组集合中最先兑现或拒绝的期约的镜像 这个方法接收一个可迭代对象 , 返回一个新期约
  </p>
  <code>
    <pre>
    let p1 = Promise.race([
      Promise.resolve(),
      Promise.resolve()
    ])

    // 可迭代对象中的元素会通过Promise.resolve() 转换为期约
    let p2 = Promise.race([3, 4])

    // 空的可迭代对象等价于 new Promise(() => {})
    let p3 = Promise.race([])

    // 无效的语法
    let p4 = Promise.race()
    //  TypeError: undefined is not iterable (cannot read property Symbol(Symbol.iterator)) at Promise.race(<anonymous>)
    </pre>
  </code>
  <p>Promise.race() 不会对兑现或拒绝的期约区别对待。无论兑现还是拒绝，只要是第一个落定的期约，Promise.race()就会包装其兑现的值或拒绝理由并返回新期约:</p>
  <code>
  <pre>
  // 解决先发生  , 超时后的拒绝被忽略
    let P1 = Promise.race([
      Promise.resolve(3),
      new Promise((resolve, reject) => setTimeout(reject, 1000))
    ])
    console.asyncLog(P1) // Promise {<fulfilled>: 3}

    // 拒绝先发生 , 超时后的解决被忽略
    let P2 = Promise.race([
      Promise.reject(4),
      new Promise((resolve, reject) => setTimeout(resolve, 1000))
    ])
    console.asyncLog(P2) // Promise {<rejected>: 4}

    //  迭代顺序决定了落定顺序
    let P3 = Promise.race([
      Promise.resolve(5),
      Promise.resolve(6),
      Promise.resolve(7)
    ])

    console.asyncLog(P3) // Promise {<fulfilled>: 5}
  </pre>
</code>
  <p>如果没有异步代码的话就是按顺序来的 , 如果有异步代码的话那就按谁最快谁来</p>
  <p>如果有一个期约拒绝，只要它是第一个落定的 ，就会成为合成期约的拒绝理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过 , 这并不影响所有包含期约正常的拒绝操作。
    与Promise.a11()类似，合成的期约会静默处理所有包含期约的拒绝操作，如下所示:
  </p>
  <code>
    <pre>
    // 虽然只有第一个期约的拒绝理由会进入 
    // 拒绝处理程序 , 第二个期约的拒绝也
    // 会被静默处理 , 不会有错误被漏掉

    let p = Promise.race([
      Promise.reject(3),
      new Promise((resolve, reject) => { setTimeout(reject, 1000) })
    ]);

    p.catch((reason) => console.asyncLog(reason)) // 3
    // 没有未处理的错误
    </pre>
  </code>
  <script>
    console.asyncLog = (...residue) => setTimeout(console.log, 0, ...residue)

    let p1 = Promise.race([
      Promise.resolve(),
      Promise.resolve()
    ])

    // 可迭代对象中的元素会通过Promise.resolve() 转换为期约
    let p2 = Promise.race([3, 4])

    // 空的可迭代对象等价于 new Promise(() => {})
    let p3 = Promise.race([])

    // 无效的语法
    let p4 = Promise.race()
    //  TypeError: undefined is not iterable (cannot read property Symbol(Symbol.iterator)) at Promise.race(<anonymous>)

    // 解决先发生  , 超时后的拒绝被忽略
    let P1 = Promise.race([
      Promise.resolve(3),
      new Promise((resolve, reject) => setTimeout(reject, 1000))
    ])
    console.asyncLog(P1) // Promise {<fulfilled>: 3}

    // 拒绝先发生 , 超时后的解决被忽略
    let P2 = Promise.race([
      Promise.reject(4),
      new Promise((resolve, reject) => setTimeout(resolve, 1000))
    ])
    console.asyncLog(P2) // Promise {<rejected>: 4}

    //  迭代顺序决定了落定顺序
    let P3 = Promise.race([
      Promise.resolve(5),
      Promise.resolve(6),
      Promise.resolve(7)
    ])

    console.asyncLog(P3) // Promise {<fulfilled>: 5}

    console.asyncLog('============================ 拒绝 ===============================');
    // 虽然只有第一个期约的拒绝理由会进入 
    // 拒绝处理程序 , 第二个期约的拒绝也
    // 会被静默处理 , 不会有错误被漏掉

    let p = Promise.race([
      Promise.reject(3),
      new Promise((resolve, reject) => { setTimeout(reject, 1000) })
    ]);

    p.catch((reason) => console.asyncLog(reason)) // 3
    // 没有未处理的错误
  </script>
</body>

</html>