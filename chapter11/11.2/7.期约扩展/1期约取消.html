<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="../../../index.css">
</head>

<body>
  <h1>期约取消</h1>
  <p>我们经常会遇到期约正在处理过程中，程序不再需要其结果的情形。这时候如果能够取消期约就好了 。某些第三方库，比如 Bluebird，就提供了这个特性。
    实际上，TC39委员会也曾准备添加这个特性 , 但相关提案最终被撤回了。结果，ECMAScript期约被认为是“激进的”:只要期约的逻辑开始执行，就
    没有办法阻止它执行到完成。
  </p>
  <p>实际上 , 可以在现有实现基础上提供一种临时性的封装 , 以实现取消期约的功能。这可以用到 KevinSmith 提到的 '取消令牌' (cancel token)。 生成令牌实例提供一个接口
    利用这个接口可以取消期约: 同时也提供了一个期约的实例 , 可以用来触发取消后的操作并求值取消状态
  </p>
  <code>
    <pre>
    class CancelToken {
      constructor(cancelFn) {
        // 实例化时，创建一个内部 Promise（this.promise）
        this.promise = new Promise((resolve, reject) => {
          // 调用外部传入的 cancelFn，并把 Promise 的 resolve 方法传出去
          cancelFn(resolve)
        })
      }
    }
    </pre>
  </code>
  <p><strong>“取消令牌” 相当于一个 “连接线”</strong>它一边暴露给外部 “取消接口”，一边让内部 Promise 能 “监听取消信号”，两者通过令牌关联起来。</p>
  <p class="retract">下面是 CancelToken类的一个基本实例</p>
  <button id="start">Start</button>
  <button id="cancel">Cancel</button>
  <script>
    console.asyncLog = (...residue) => setTimeout(console.log, 0, ...residue)

    class CancelToken {
      constructor(cancelFn) {
        this.promise = new Promise((resolve, reject) => {
          cancelFn(() => {
            console.asyncLog('delay cancelled')
            resolve()
          })
        })
      }
    }

    const startButton = document.querySelector('#start')
    const cancelButton = document.querySelector('#cancel')

    function cancellableDelayedRedolve(delay) {
      console.asyncLog('set delay') // 设置延迟

      return new Promise((resolve, reject) => {
        const id = setTimeout((() => {
          console.asyncLog('delay resolve*')
          resolve()
        }), delay)

        const cancelToken = new CancelToken((cancelCallback) =>
          cancelButton.addEventListener('click', cancelCallback))

        cancelToken.promise.then(() => clearTimeout(id))
      })
    }

    startButton.addEventListener('click', () => cancellableDelayedRedolve(1000))
  </script>
  <p>这段代码讲的绑定了2个DOM对象 , 一个是 <strong>startButton</strong> 一个是 <strong>cancelButton</strong> , 当点击 startButton 的时候会触发
    cancellableDelayedRedolve延迟函数 先是打印了'set delay' 然后返回一个Promise 里面设置了一个倒计时 , 同时还设置了 cancelToken 实例化了
    CancelToken类的一个基本实例
    这个类先是给cancelToken 设置了一个Promise , 并且时给 <strong>实例化时传入的箭头函数</strong>也就是(cancelCallback) => { ... } , 的
    <strong>cancelCallback参数</strong> : 因为传入的是箭头函数所以cancelFn是传进来的箭头函数 , 然后再 <strong>箭头函数(() => {}) 就是给cancelCallback
      赋值成箭头函数嘛</strong> 最后就是给 <strong>cancelButton</strong> 绑定事件 , 当点击就会触发下面的 取消倒计器API的函数 <strong>也就是你看到的
      CancelToken</strong>
    里面的Proimse变成了<strong>resolve()</strong> 自然会执行下面的 <strong>cancelToken.promise.then</strong>
    具体代码看源代码
  </p>
  <p><strong>书上的:</strong>
    每次单击“Start”按钮都会开始计时，并实例化一个新的cancelToken的实例。此时，"Cancel"按钮一旦被点击，就会触发令牌实例中的期约解决。而解决之后，单击"start"按钮设置的超时也会取消</p>
</body>

</html>