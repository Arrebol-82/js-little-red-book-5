<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="../../../index.css">
</head>

<body>
  <h1>使用Promise.prototype.catch()</h1>
  <p>Promise.prototype.catch()方法用于给期约添加拒绝处理程序。这个方法只接收一个参数: onRejected处理程序 事实上 , 这个方法就是一个语法糖 , 调用它相当于调用
    Promise.prototype.then(null , onRejected)
  </p>
  <p class="retract">下面的代码展示了这两种同样情况</p>
  <code>
    <pre>
    let p = Promise.reject()
    let onRejected = function (e) {
      console.asyncLog('rejected')
    }

    // 这两种添加拒绝处理程序的方式是一样的: 
    p.then(null, onRejected)  // rejected
    p.catch(onRejected)       // rejected
    </pre>
  </code>
  <p>Promise.prototype.catch() 返回一个新的期约实例</p>
  <code>
    <pre>
    let p1 = new Promise(() => { })
    let p2 = p1.catch()
    console.asyncLog(p1) // Promise {<pending>}
    console.asyncLog(p2) // Promise {<pending>}
    console.asyncLog(p1 === p2) // false
    </pre>
  </code>
  <p>在返回新期约实例方面 , promise.prototype.catch() 的行为与 Promise.prototype.then()的onRejected 处理程序是一样的</p>
  <script>
    console.asyncLog = (...residue) => setTimeout(console.log, 0, ...residue)

    // 下面的代码展示了这两种同样情况
    let p = Promise.reject()
    let onRejected = function (e) {
      console.asyncLog('rejected')
    }

    // 这两种添加拒绝处理程序的方式是一样的: 
    p.then(null, onRejected)  // rejected
    p.catch(onRejected)       // rejected

    // Promise.prototype.catch() 返回一个新的期约实例
    let p1 = new Promise(() => { })
    let p2 = p1.catch()
    console.asyncLog(p1)   // Promise {<pending>}
    console.asyncLog(p2)   // Promise {<pending>}
    console.asyncLog(p1 === p2) // false
  </script>
</body>

</html>