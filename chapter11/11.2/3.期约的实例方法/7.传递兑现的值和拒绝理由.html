<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="../../../index.css">
</head>

<body>
  <h1>传递兑现的值和拒绝的理由</h1>
  <p>到了落定状态后、期约会提供其兑现的值(如果兑现)或其拒绝理由(如果拒绝)给相关状态的处理程序 拿到返回值后 , 就可以进一步对这个值进行操作。比如 , 第一次网络请求返回的JSON是发送
    第二次请求必须的数据 , 那么第一次请求返回的值就应该传给onFulifilled 处理程序继续处理 。当然失败的网络请求也应该把HTTP状态码传给onRejected 处理程序
  </p>
  <p><strong>大白话:</strong>如果第一访问出错的话 , 那么在访问的话很有可能还是错的 , 所以要放到 onFulfilled 而且还能依赖第一次访问的值 , 如果是失败的话放到onRejected会更好 ,
    因为onRejected可以直接给你看到访问错误的信息</p>
  <p class="retract">在执行器函数中,兑现的值和拒绝的理由是分别作为resolve()和reject()的第一个参数往后传递的 , 然后 , 这些值又会传给他们各自的处理程序
    作为onFulfi1led或onRejected 处理程序的唯一参数 , 下面的例子展示了上述传递过程
  </p>
  <code>
    <pre>
    let p1 = new Promise((resolve, reject) => resolve('foo'))
    p1.then((value) => console.log(value)) // foo
    
    let p2 = new Promise((resolve, reject) => reject('bar'))
    p2.catch((reason) => console.log(reason)) // Uncaught (in promise) bar
    </pre>
  </code>
  <p>Promise.resolve()和Promise.reject()在被调用时就会接收兑现的值和拒绝理由。同样地 , 它们返回的期约也会像执行器函数一样把这些值传给 onFulfilled 或 onRejected 处理程序
  </p>
  <code>
    <pre>
    let P1 = Promise.resolve('foo')
    P1.then((value) => console.log(value)) // foo
    
    let P2 = Promise.reject('bar')
    P2.catch((reason) => console.log(reason)) // bar
    </pre>
  </code>
  <p>这两种方法都是一样的 , 看你喜欢那种吧</p>
  <script>
    let p1 = new Promise((resolve, reject) => resolve('foo'))
    p1.then((value) => console.log(value)) // foo

    let p2 = new Promise((resolve, reject) => reject('bar'))
    p2.catch((reason) => console.log(reason)) // bar

    let P1 = Promise.resolve('foo')
    P1.then((value) => console.log(value)) // foo

    let P2 = Promise.reject('bar')
    P2.catch((reason) => console.log(reason)) // bar
  </script>
</body>

</html>