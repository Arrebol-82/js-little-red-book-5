<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="../../../index.css">
</head>

<body>
  <h1>期约状态机</h1>
  <p>在把一个期约实例传给 console.asyneteg()时，控制台输出 (可能因浏览器不同而略有差异) 表明该实例处于<strong>待定(pending)</strong>状态 如前所述 期约是一个有状态的对象 ,
    可能处于如下3种状态 <strong>之一</strong></p>
  <ul>
    <li class="circle">待定 <strong>(pending)</strong></li>
    <li class="circle">兑现(成功) <strong>(fulfilled 有时候也称为 '解决' , resolved)</strong></li>
    <li class="circle">拒绝 <strong>(rejected)</strong></li>
  </ul>
  <P><strong>待定(pending)</strong>是期约的最初始状态 (也就是还未执行) 。在待定状态下，期约可以<strong>落定(semled)</strong>为代表成功的 <strong>
      兑现(fulfilled)</strong> 亦或者是失败的 <strong>拒绝(rejected)</strong> 无论落定为哪种状态都是不可逆的。只要从待定装换为兑现或者拒绝 , 期约的状态就不会改变
    而且,也不能保证期约必然会脱离待定状态( <strong>执行器函数里没有调用resolve（触发兑现）、没有调用reject（触发拒绝）、也没有抛出任何错误（会自动触发拒绝），那么这个 Promise 就会一直停留在
      “待定（pending）” 状态，永远不会 “落定”。</strong> ) . 因此, 无论期约解决(resolve)还是拒绝(reject)，甚至永远处于待定(pending)状态，组织合理的代码都应该具有恰当的行为</P>
  <p class="retract">
    重要的是，期约的状态是私有的，不能直接通过JavaScript检测到。这主要是为了避免根据读取到的期约状态以同步方式处理期约对象。另外，期约的状态也不能被外部JavaScript代码修改。这与不能读取该状态的原因是一样的:期约故意将异步行为封装起来，从而隔离外部的同步代码。
  </p>
  <script>
    console.asyncLog = (...residue) => setTimeout(console.log, 0, ...residue)

  </script>
</body>

</html>