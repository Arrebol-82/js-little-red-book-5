<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../index.css">
</head>

<body>
    <h1>原生对象原型</h1>
    <p>原型模式之所以重要 ， 不仅仅体现在自定义类型上 ， 还因为它也是实现所有原生引用类型的模式。所有
        原生引用类型的构造函数 （包括Object ， Array ， String 等）都在原型上定义了实例方法
    </p>
    <strong>比如： 数组的实例的sort（）方法就是Array.prototype上定义的，而字符串包装对象的substring方法也是在String.prototype</strong>
    <h2 class="pink">其实用一句话总结的话： 就是每个对象身上都有一个[[prototype]](日常理解的__proto__)他是专门指向构造函数的原型对象 ，所以访问的话是会报错的里面并没有这个属性,
        这样才能实现使用Object ， Array 等等这些类型身上的方法
    </h2>
    <p class="skyblue">通过原生对象的原型可以取得所有的默认方法的引用 ，也可以给原生类型的实例定义新的方法。可以修改自定义对象原型一样修改原生对象原型，因此随时可以添加方法 看例子</p>
    <code>
        <pre>
            String.prototype.startsWith = function (text) {
                return this.indexOf(text) === 0
                // indexOf用于判断元素首次出现的位置 
            }
    
            let msg = 'Hello world!'
            console.log(msg.startsWith('Hello'));
        </pre>
    </code>
    <p>如果开头出现了调用startsWith() 方法时传入文本 ， 那么该方法会返回true 因为这个方法是定义在String.prototype上 ， 所以在当前环境下所有的字符串地可以使用这个方法
        msg在调用startsWith()方法的时候 ， 引擎会自动创建String的包装实例 ， 然后在去实例对象和原型对象上找到startsWith()方法 ,最后调用
    </p>
    <section>
        <h1>注意 ！！！</h1>
        <strong>尽管可以这么做，但并不推荐在生产环境中修改原生对象原型。 这样做可以很可能造成误会 ，而且可能引发命名冲突 ， 推荐的做法就是创建一个自定义的类型，继承原生类型</strong>
    </section>
    <script>
        console.log(typeof Array.prototype.sort);
        console.log(typeof String.prototype.substring);

        String.prototype.startsWith = function (text) {
            return this.indexOf(text) === 0
            // indexOf用于判断元素首次出现的位置 
        }

        let msg = 'Hello world!'
        console.log(msg.startsWith('Hello'));
    </script>
</body>

</html>