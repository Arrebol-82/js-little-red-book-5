<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="../../../index.css">
</head>

<body id="someNode">
  <p>测试</p>
  <h1>操纵节点</h1>
  <p>因为所有关系指针都是只读的 , 所以 DOM 又提供了一些操纵节点的方法 。最常用的方法是 appendChild () <strong>添加子节点</strong>
    用于在childNodes 列表末尾添加节点。添加新节点会更新相关的关系指针,父节点和之前的最后一个子节点。appendchild()方法返回新添加的节点，如下所示:</p>
  <code>
      <pre>
    const someNode = document.getElementById('someNode')

    const newNode = document.createElement(`p`)
    let returnedNode = someNode.appendChild(newNode)
    returnedNode.innerHtml = `新添加的子节点`
    console.log(returnedNode);
    console.log(returnedNode == newNode);  // true
    console.log(someNode.lastChild == newNode); // true
      </pre>
  </code>
  <p>如果把文档中已经存在的节点传给appendchild(),则这个节点会从之前的位置被转移到新位置即使
    DOM树通过各种关系指针维系，一个节点也不会在文档中同时出现在两个或更多个地方。<strong>(这里说的是节点对象)</strong>此如果调用
    appendchild()传人父元素的第一个子节点，则这个节点会成为父元素的最后一个子节点</p>
  <code>
      <pre>
    // 假设 someNode 有多个子节点
    // 传入第一个子节点
    let ReturnedNode = someNode.appendChild(someNode.firstChild)
    console.log(ReturnedNode === someNode.firstChild); // false
    console.log(ReturnedNode === someNode.lastChild);  // true 
      </pre>
  </code>
  <p>如果想把节点放到 childNodes 中的特定位置而不是末尾 , 则可以 <strong>使用 insertBefore() 方法</strong>
    。这个方法接收两个参数:要插人的节点和参照节点。调用这个方法后，要插入的节点会变成参照节点的前一个同胞节点 , 并被返回 。 如果参照节点是 null
    则 insertBefore()与 appendchild() 效果相同 , 如下面的例子所示:</p>
  <code>
      <pre>
    // 作为最后一个子节点插入
    ReturnedNode = someNode.insertBefore(newNode, null)
    console.log(newNode == someNode.lastChild); // true
    
    // 作为新的第一个子节点插入
    ReturnedNode = someNode.insertBefore(newNode, someNode.firstChild)
    console.log(ReturnedNode === newNode)
    console.log(someNode.firstChild === newNode)
    
    // 插入最后一个子节点前面
    <strong>就是因为它是会插在第二个参数节点的前面</strong>
    ReturnedNode = someNode.insertBefore(newNode, someNode.lastChild)
    console.log(newNode === someNode.childNodes[someNode.childNodes.length - 2]);
      </pre>
    </code>
  <p>appendchi1d()和 inserteefore() 在插入节点时不会删除任何已有节点。相对地 , replaceChild()万法接收两个参数 : 要插入的节点和要替换的节点 。 要替换的节点会被返回并从文档树中完全移除
    ,要插入的节点取而代之 , 下面看一个例子:</p>
  <code>
      <pre>
    // 替换第一个子节点 
    ReturnedNode = someNode.replaceChild(newNode, someNode.firstChild)

    // 替换最后一个子节点
    ReturnedNode = someNode.replaceChild(newNode, someNode.firstChild)
      </pre>
    </code>
  <p>使用replacechild()插人一个节点后,所有关系指针都会从被替换的节点复制过来。虽然被替换的节点从技术上说仍然被同一个文档所拥有，但文档中已经没有它的位置。<strong>：被替换的节点并没有 “销毁”，只是从 DOM
      树中 “移除” 了（不再处于文档的结构中），但它仍然是当前文档的 “成员”（ownerDocument 不变），可以被再次使用。</strong>只是暂时从 DOM树中移除了 , 但是如果移除的时候进行保存的 ,
    还是可以继续把他添加到DOM树中的 , 归根结底他还是文档中</p>
  <p class="circle">要移除节点而不是替换节点，可以使用removechi1d()方法。这个方法接收一个参数，即要移除的节点。被移除的节点会被返回，如下面的例子所示:</p>
  <code>
    <pre>
    // 删除第一个子节点
    ReturnedNode = someNode.removeChild(someNode.firstChild)

    // 删除最后一个子节点
    ReturnedNode = someNode.removeChild(someNode.lastChild)
    </pre>
  </code>
  <p>与replacechild()方法一样，通过removechild()被移除的节点从技术上说仍然被同一个文档所拥有，但文档中已经没有它的位置。</p>
  <p>上面介绍的4个方法都用于操纵某个节点的子元素， <strong>( appendChild , insertBefore , replaceChild , removeChild)</strong> 也就是说使用它们之前
    <strong>必须先取得父节点(使用前面介绍的parentNode属性)。</strong>并非所有节点类型都有子节点，如果在不支持子节点的节点上调用这些方法，则会导致抛出错误。
  </p>
  <script>
    const someNode = document.getElementById('someNode')

    const newNode = document.createElement(`p`)
    newNode.textContent = `新添加的子节点`
    let returnedNode = someNode.appendChild(newNode)
    console.log(returnedNode);
    console.log(returnedNode == newNode);  // true
    console.log(someNode.lastChild == newNode); // true

    // 假设 someNode 有多个子节点
    // 传入第一个子节点
    let ReturnedNode = someNode.appendChild(someNode.firstChild)
    console.log(ReturnedNode === someNode.firstChild); // false
    console.log(ReturnedNode === someNode.lastChild);  // true

    // 作为最后一个子节点插入 
    ReturnedNode = someNode.insertBefore(newNode, null)
    console.log(newNode == someNode.lastChild); // true

    // 作为新的第一个子节点插入
    ReturnedNode = someNode.insertBefore(newNode, someNode.firstChild)
    console.log(ReturnedNode === newNode)
    console.log(someNode.firstChild === newNode)

    // 插入最后一个子节点前面
    ReturnedNode = someNode.insertBefore(newNode, someNode.lastChild)
    console.log(newNode === someNode.childNodes[someNode.childNodes.length - 2]);

    // 替换第一个子节点 
    ReturnedNode = someNode.replaceChild(newNode, someNode.firstChild)

    // 替换最后一个子节点
    ReturnedNode = someNode.replaceChild(newNode, someNode.firstChild)

    // 删除第一个子节点
    ReturnedNode = someNode.removeChild(someNode.firstChild)

    // 删除最后一个子节点
    ReturnedNode = someNode.removeChild(someNode.lastChild)
  </script>
</body>

</html>