<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="../../../index.css">
</head>

<body>
  <h1>attributes 属性</h1>
  <p>Element 类型是唯一使用 attributes 属性的DOM节点类型。attributes属性包含一个NamedNodeMap 实例 , 是一个类似NodeList 的 '实时' 集合。元素的每个属性都表示为一个Attr节点
    , 并保存在这个NameNodeMap对象中 , 属性的DOM节点类型。attributes属性包含一个NamedNodeMap对象包含下列方法:</p>
  <ul>
    <li>getNamedItem(name), 返回nodeName 属性等于name的节点</li>
    <li>setNamedItem(node), 向列表中添加node节点 , 以其nodeName为索引</li>
    <li>removeNamedItem(name), 删除nodeName 属性等于name的节点</li>
    <li>item(pos) , 返回索引位置 <i>pos</i> 处的节点</li>
  </ul>
  <p>attributes属性中的每个节点的nodeName是对应属性的名字 , nodeValue是属性的值 。 比如, 要取得元素id属性的值 , 可以使用以下代码:</p>
  <div id="ele" lang="en" dir="auto">实例代码</div>
  <code>
    <pre>
    let id = element.attributes.getNamedItem('id').nodeValue

    console.log(id)
    </pre>
  </code>
  <p>下面是使用中括号访问属性的简写形式</p>
  <p>let id = element.attributes['id'].nodeValue</p>
  <p>同样，也可以用这种语法设置属性的值，即先取得属性节点，再将其odevalue设置为新值, 如下所示:</p>
  <code>
    <pre>
    element.attributes['id'].nodeValue = 'someOtherId'
    
    console.log(element.id) // someOtherId
    </pre>
  </code>
  <p>removeNamedItem()方法与元素上的removeAttribute() 方法类似 , 也是删除指定名字的属性 。 下面的例子展示了这两个方法唯一的不同之处 ,
    就是removeNamedItem() 返回表示被删除属性的Attr 节点:</p>
  <code>
    <pre>
    let oldAttr = element.attributes.removeNamedItem('id')
    
    console.log(oldAttr, element.id) // 空的 id = ' someOtherId'
    </pre>
  </code>
  <p>setNamedItem()方法很少使用，它接收一个属性节点，然后给元素添加一个新属性，如下所示:</p>
  <code>
    <pre>
    const classAttr = document.createAttribute('class');
    
    classAttr.value = 'active';
    
    element.attributes.setNamedItem(classAttr)

    <strong>在开发中更推荐使用setAttribute(属性名, 属性值) 方法 , 方便 , 快捷</strong>
    </pre>
  </code>
  <p>一般来说,因为使用起来更简便,通常开发者更喜欢使用getAttribute()、removeAttribute()和 setattribute()方法，而不是刚刚介绍的NamedNodeMap 对象的方法。</p>
  <p>attributes属性最有用的场景是需要迭代元素上所有属性的时候 。 这时候往往是要把DOM结构序列化为XML或HTML字符串。 比如，以下代码能够迭代一个元素上的所有属性并以attribute1="value1"
    attribute2="value2"的形式生成格式化字符串:</p>
  <code>
      <pre>
    function outputAttributes(element) {
      let pairs = []

      for (let i = 0, len = element.attributes.length; i < len; ++i) {
        const attribute = element.attributes[i]
        pairs.push(`${attribute.nodeName} = ${attribute.nodeValue}`)
      }
      return pairs.join(' ')
    }

    console.log(outputAttributes(element)) // lang = en dir = auto class = active

        <strong>这里的 join 是连接符 , 用于将数组里面的元素按照连接符里面的值 , 连起来 , 最终返回一个字符串</strong>
      </pre>
    </code>
  <p>这个函数使用数组存储每个名/值对,迭代完所有属性后,再将这些名/值对用空格拼接在一起。(这个技术常用于序列化为长字符串。)
    这个函数中的for 循环使用attributes.length属性迭代每个属性 ,
    将每个属性的名字和值输出为字符串。不同浏览器返回的attributes中的属性顺序也可能不一样HTML或XML代码中属性出现的顺序不一定与attributes中的顺序一致。</p>
  <script>
    const element = document.getElementById('ele')

    console.log(element)
    let id = element.attributes.getNamedItem('id').nodeValue

    // let id = element.attributes['id'].nodeValue
    console.log(id)

    element.attributes['id'].nodeValue = 'someOtherId'

    console.log(element.id)

    let oldAttr = element.attributes.removeNamedItem('id')

    console.log(oldAttr, element.id)  // 空的  id = ' someOtherId'

    const classAttr = document.createAttribute('class');

    // 2. 给属性节点设置值
    classAttr.value = 'active';

    element.attributes.setNamedItem(classAttr)

    function outputAttributes(element) {
      let pairs = []

      for (let i = 0, len = element.attributes.length; i < len; ++i) {
        const attribute = element.attributes[i]
        pairs.push(`${attribute.nodeName} = ${attribute.nodeValue}`)
      }
      return pairs.join(' ')
    }

    console.log(outputAttributes(element)) // lang = en dir = auto class = active
  </script>
</body>

</html>