<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="../../index.css">
</head>

<body>
  <h1>DocumentFragment 类型</h1>
  <p>在所有节点类型中，DocumentFragment类型是唯一一个在标记中没有对应表示的类型。DOM将这种文档片定义为 "轻量级" 文档, 它能够包含和操作节点 ,
    却没有完整文档那样额外的消耗 , DocumentFragment 节点具有以下特征:
  </p>
  <ul>
    <li>nodeType 等于 11</li>
    <li>nodeName 值为"#document-fragment"</li>
    <li>nodeValue 值为null</li>
    <li>parentNode 值为null</li>
    <li>子节点可以是Element、ProcessingInstruction、Comment、Text、CDATASection 或
      EntityReference.</li>
  </ul>
  <p>不能直接把文档片段添加到文档。相反，文档片段的作用是充当其他要被添加到文档的节点的仓库可以使用
    document.createDocumentFragment()方法像下面这样创建文档片段:</p>
  <p>let fragment = document.createDocumentFragment()</p>
  <p>文档片段从ode类型继承了所有文档类型具备的可以执行DOM操作的方法。如果文档中的一个节点被添加到一个文档片段 , 则该节点会从文档树中移除，
    不会再被浏览器渲染。添加到文档片段的新节点同样不属于文档树，可以通过appendchild()或insertBefore()方法将文档片段的内容添加到文档。
    在把文档片段作为参数传给这些方法时，这个文档片段的所有子节点会被添加到文档中相应的位置。文档片段本身永远不会被添加到文档树。以下面的HTML为例:
  </p>
  <p> &lt;ul id="myList">&lt;/ul></p>
  <ul id="myList"></ul>
  <p>假设想给这个&lt;u1>元素添加3个列表项。如果分3次给这个元素添加列表项,浏览器就要重新渲染3次页面，以反映新添加的内容。为避免多次渲染，下面的代码示例使用文档片段创建了所有列表项.然后一次性将它们添加到了&lt;u1>元素:
  </p>
  <code>
    <pre>
    let fragment = document.createDocumentFragment()

    let ul = document.getElementById('myList')

    for (let i = 0; i < 3; i++) {
      let li = document.createElement('li')
      li.appendChild(document.createTextNode(`Item ${i + 1}`))
      fragment.appendChild(li)
    }

    ul.appendChild(fragment)
    </pre>
  </code>
  <p>
    这个例子先创建一个文档片段，然后取得&lt;u1>元素的引用。接着通过or循环创建了3个列表项,每一项都包含表明自己身份的文本。为此先创建&lt;11>元素，再创建文本节点并添加到该元素。然后通过eppendchild()把&lt;1i>
    元素添加到文档片段。循环结束后，通过把文档片段传给appendchild()将所有列表项添加到了&lt;u1>元素。此时，文档片段的子节点全部被转移到了&lt;u1>元素中。</p>
  <script>
    let fragment = document.createDocumentFragment()

    let ul = document.getElementById('myList')

    for (let i = 0; i < 3; i++) {
      let li = document.createElement('li')
      li.appendChild(document.createTextNode(`Item ${i + 1}`))
      fragment.appendChild(li)
    }

    ul.appendChild(fragment)
  </script>
</body>

</html>