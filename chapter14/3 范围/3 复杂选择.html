<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <h1>复杂选择</h1>
  <p>要创建复杂的范围 , 需要使用setStart() 和 setEnd()方法 。这两个方法都接收两个参数:参照节点和偏移量 。 对setStart() 来说, 参照节点会成为 startContainer ,
    而偏移量会赋值给startOffset。
    对setEnd() 而言 , 参照节点会成为endcontainer，而偏移量会赋值给 endoffset. <strong>setStart 是包含当前选中的节点或字符的 而 setEnd 是不包含当前节点或字符</strong>
  </p>
  <p>使用这两个方法 , 可以模拟 selectNode() 和 selectNodeContents()的行为 。 比如</p>
  <code>
    <pre>
    let range1 = document.createRange(),
      range2 = document.createRange(),
      p1 = document.getElementById('p1'),
      p1Index = -1

    for (let i = 0; i < p1.parentNode.childNodes.length; i++) {
      if (p1.parentNode.childNodes[i] === p1) {
        p1Index = i
        break
      }
    }

    range1.setStart(p1.parentNode, p1Index)
    range1.setEnd(p1.parentNode, p1Index + 1) // 包含 p 节点和所有子节点 (&lt;p id="p1">&lt;b>Hello&lt;/b> world!&lt;/p>)
    range2.setStart(p1, 0)
    range2.setEnd(p1, p1.childNodes.length) // 不包含p节点 , 只有子节点 (&lt;b>Hello&lt;/b> world!)
    </pre>
  </code>
  <p id="p1"><b>Hello</b> world!</p>
  <p>注意，要选择节点(使用range1)，必须先确定给定节点(p1)在其父节点 childNodes 集合中的索引 。 而要选择节点的内容 (使用 range2 ), 则不需要这样计算 , 因为可以直接给
    setStart() 和 setEnd()传默认值。虽然可以模拟selectNode()和 selectNodecontents()，但 setStart() 和 setEnd() 真正的威力还是选择接节点的某个部分
  </p>
  <p>假设我们想通过范围从前面示例中选择从"Hello"中的“llo"到”world!"中的"o”的部分</p>
  <code>
    <pre>
    let helloNode = p1.firstChild.firstChild, // Hello
    worldNode = p1.lastChild // world!
    </pre>
  </code>
  <p>文本"hello"其实是&lt;p>的孙子节点，因为它是&lt;b>的子节点。为此可以使用p1.firstchi1d 取得 &lt;b>,
    而使用p1.firstchild.firstchild取得"He11o"这个文本节点。文本节点 "world!"
    是&lt;p>的第二个 (也是最后一个)子节点，因此可以使用p1.1astchi1d 来取得它。然后，再创建范围, 指定其边界，如下所示:
  </p>
  <code>
    <pre>
    let range = document.createRange()
    range.setStart(helloNode, 2)
    range.setEnd(worldNode, 3)  // llo&lt;/b> wo
    </pre>
  </code>
  <img src="../../index.css" alt="">
  <p>因为 helloNode 和 worldNode 是文本节点，所以它们会成为范围的 startContainer 和 endContainer , 这样 startOffset 和 endOffset
    实际上表示每个节点中文本字符的位置,而不是子节点的位置(传入元素节点时的情形)。而commonAncestorcontainer 是&lt;p>元素，即包含这两个节点的第一个祖先节点
  </p>
  <p>当然，只选择文档中的某个部分并不是特别有用，除非可以对选中部分执行操作。</p>
  <script>
    let range1 = document.createRange(),
      range2 = document.createRange(),
      p1 = document.getElementById('p1'),
      p1Index = -1

    for (let i = 0; i < p1.parentNode.childNodes.length; i++) {
      if (p1.parentNode.childNodes[i] === p1) {
        p1Index = i
        break
      }
    }

    range1.setStart(p1.parentNode, p1Index)
    range1.setEnd(p1.parentNode, p1Index + 1) // 包含 p 节点和所有子节点 (<p id="p1"><b>Hello</b> world!</p>)
    range2.setStart(p1, 0)
    range2.setEnd(p1, p1.childNodes.length) // 不包含p节点 , 只有子节点 (<b>Hello</b> world!)

    let helloNode = p1.firstChild.firstChild,  // Hello
      worldNode = p1.lastChild  //  world!

    let range = document.createRange()
    range.setStart(helloNode, 2)
    range.setEnd(worldNode, 3)  // llo</b> wo
  </script>
</body>

</html>