<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>

    const itertor = [
      Array.of(1, 2),
      tyedarray = Int16Array.of(3, 4),
      new Map([[5, 6], [7, 8]]),
      new Set([9, 10])
    ]

    for (const iter of itertor) {
      for (const it of iter) {
        console.log(it);

      }
    }
    console.log('=========== 展开 ===========');

    const a = [1, 2, 3, 4, [1, 3]]
    const b = [...a]
    a[0] = 5
    a[4][0] = 5
    console.log(b);
    console.log(a);

    // 因为在...a 的时候是b是有自己的独立的地址值, 但是里面的内容是指向同一个地址值
    console.log(a === b);
    console.log(a == b);

    console.log('=========== 构造函数 ============');

    const mp1 = new Map([[1, 2], [3, 4]])
    const mp2 = new Map(mp1)
    console.log(mp1);
    console.log(mp2);

    console.log('=========== 构造数组 ===========');

    const arr1 = [1, 2, 3]
    const arr2 = [0, ...arr1, 4, 5]
    console.log(arr2);

    console.log('=========== 复制对象 ===========');
    const Arr1 = [{}]
    const Arr2 = [...Arr1]

    Arr1[0].foo = 'bar'
    console.log(Arr2[0]);  // 同一个索引

    console.log('============ 定型数组 ============');
    const ARR1 = [1, 2, 3]
    const typeArr1 = Int16Array.of(...ARR1)
    const typeArr2 = Int16Array.from(ARR1)

    console.log(typeArr1);
    console.log(typeArr2);

    console.log('=========== map ============');

    let map = new Map(ARR1.map(x => [x, 'val' + x]))
    console.log(map);
    let set = new Set(typeArr2)
    console.log(set);
    let arr3 = [...set]
    console.log(arr3);



  </script>
</body>

</html>