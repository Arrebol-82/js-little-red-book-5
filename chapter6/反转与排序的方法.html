<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    li {
      list-style: decimal;
    }
  </style>
</head>

<body>
  <h1>反转与排序的方法 (都是直接修改原数组)</h1>
  <h2>reverse()</h2>
  <p><strong>是直接修改元素组</strong> 原地反转数组</p>
  <ul>
    <li>就只会将数组反转够来</li>
  </ul>
  <code>
    <pre>
      <strong>原地反转数组</strong>
      let value = [1, 2, 3, 4, 5]
      value.reverse()
      console.log(value); // [5, 4, 3, 2, 1]
      // let value1 = [3, 4, 1, 2, 5]
      let value1 = ['0', '1', '5', '10', '15']
      value1.reverse()
      console.log(value1);
    </pre>
  </code>
  <h2>sort()</h2>
  <p>如果sort()里面为空的话,是先将排序的值转换用Unicode编码后的值</p>
  <p>有的话就不会进行编码转换了</p>
  <p>因此sort()方法就会提供了 <strong>函数</strong></p>
  <p>比较函数返回负数、0、正数时，分别决定前一个元素是「排在前面」「不变」「排在后面」。</p>
  <ul>
    <li>第一个参数应该排在前面就应该返回负值 , 如果两个参数相等就应该返回 0; 第一个参数排在后面的话就是返回 正值</li>
  </ul>
  <p>当数组元素是数值，或者对象通过  valueOf()  方法能返回数值时，使用  return value2 - value1  这种比较函数形式，在  sort()  方法中就可以快速实现降序排序 。因为  value2 -
    <br>
    value1  结果大于 0 时， value2  会排在  value1  前面；结果小于 0 时， value1  会排在  value2  前面；结果为 0 时顺序不变，整体呈现降序效果。
  </p>
  <h3>localeCompare()</h3>
  <p>localeCompare  方法是根据指定的语言环境或默认的语言环境进行字符串比较。</p>
  <code>
    <pre>

    </pre>
  </code>
  <script>
    let value = [1, 2, 3, 4, 5]
    value.reverse()
    console.log(value); // [5, 4, 3, 2, 1]
    // let value1 = [3, 4, 1, 2, 5]
    let value1 = ['0', '1', '5', '10', '15']
    value1.reverse()
    console.log(value1);

    console.log('sort()   ====================================');
    // 如果sort()里面为空的话, 是先将排序的值转换用Unicode编码后的值
    let values = [0, 1, 5, 10, 15]
    values.sort()
    console.log(values);

    // 这是升序函数
    function compare(a, b) {
      if (a > b) {
        return 1
      } else if (a < b) {
        return -1
      } else {
        return 0
      }
    }

    // 反过来就降序了
    function comp(a, b) {
      if (a > b) {
        return -1
      } else if (a < b) {
        return 1
      } else {
        return 0
      }
    }

    // 此时传入函数不会编码 ，执行函数
    values.sort(compare)
    console.log(values);

    values.sort(comp)
    console.log(values);

    values.sort((a, b) => a < b ? 1 : a > b ? -1 : 0)
    console.log(values);

    // 升序
    values.sort((a, b) => a - b)
    console.log(values);

    // 降序
    values.sort((a, b) => b - a)
    console.log(values);

    // 字符串升序
    // localeCompare根据当前的语言环境进行对比
    values.sort((a, b) => a.localeCompare(b))
    console.log(values);

    // 字符串降序
    values.sort((a, b) => b.localeCompare(a))
    console.log(values);

    // 数值属性升序
    values.sort((a, b) => a.foo - b.foo)
    console.log(values);

    // 字符串属性升序
    values.sort((a, b) => a.foo.localeCompare(b.foo))
    console.log(values);

    // 字符串属性升序,空值排在最后面
    values.sort((a, b) => {
      if (a.foo === '') {
        return 1
      }
      if (b.foo === '') {
        return -1
      }
      return a.foo.localeCompare(b.foo)
    })
    console.log(values);

  </script>
</body>

</html>