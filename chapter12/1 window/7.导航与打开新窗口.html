<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="../../index.css">
</head>

<body>
  <section>
    <h2>导航与打开新窗口</h2>
    <p>window.open()方法可以用于导航到指定URL，也可以用于打开新浏览器窗口。这个方法接收4个参数: 要加载的URL , 目标窗口 , 特性字符串和
      表示新窗口在浏览器历史记录中是否替代当前加载页面的布尔值。通常，调用这个方法时只传前3个参数，最后一个参数只有在不打开新窗口时才会使用。
    </p>
    <p class="retract">如果 window.open()的第二个参数是一个已经存在的窗口或窗格(fame)的名字，则会在对应的窗口或窗格中打开 URL。下面是一个例子:</p>
    <a href="http://www.wiley.com" target="topFrame">链接</a>
    <code>
    <pre>
      // 与<a href="http://www.wiley.com" target="topFrame">a</a> 相同
      window.open("http://www.wiley.com/","topFrame" );
    </pre>
  </code>
    <p>执行这行代码的结果就如同用户点击了一个href属性为"http://www.wiley.com"、target属性为 "topFrame"的链接 如果有一个窗口名叫 "topFrame" ,
      则这个窗口就会打开这个 URL，否则就会打开一个新窗口并将其命名为"topFrame"。第二个参数也可以是一个特殊的窗口名，比如_self , _parent、_top 或_blank。
    </p>
    <h2>弹出窗口</h2>
    <p>如果 window.open()的第二个参数不是已有窗口，则会打开一个新窗口或标签页。第三个参数, 即特性字符串，用于指定新窗口的配置。如果没有传第三个参数，则新窗口(或标签页)会带有所有默认
      的浏览器特性(工具栏、地址栏、状态栏等都是默认配置)。如果打开的不是新窗口，则忽略第三个参数 <strong>( 简单理解就是设置浏览器的外观 )</strong>
    </p>
    <p class="retract">特性字符串是一个逗号分隔的字符串，用于设置新窗口包含的特性。下表列出了一些选项。</p>
    <code>
    <pre>
        <strong>_________________________________________________________________________________________________________________</strong>
        <strong>       设    置             值                                      说明</strong>
         _______________________________________________________________________________________________________________________________
                        height             数值                              新窗口高度。这个值不能小于100

                        width              数值                              新窗口的宽度。这个值不能小于100
                        
                        left               数值                              新窗口的x轴坐标。这个值不能是负值

                        top                数值                              新窗口的y轴坐标。这个值不能是负值

                        location        "yes"或"no"                          表示是否显示地址栏。不同浏览器的默认值不一样。在设置为"no"时，
                                                                             地址栏可能隐藏或禁用(取决于浏览器)

                        menubar         "yes"或"no"                          表示是否显示菜单栏。默认为"no"                                                     

                        resizable       "yes"或"no"                          表示是否可以拖动改变新窗口大小。默认为"no"

                        scrollbars      "yes"或"no"                          表示是否可以在内容过长时滚动。默认为"no"   

                        status          "yes"或"no"                          表示是否显示状态栏。不同浏览器的默认值不一样

                        toolbar         "yes"或"no"                          表示是否显示工具栏。默认为"no”
    </pre>
  </code>
    <p><strong>注意</strong> 其中一些选项 ( 例如 toolbar (显示工具栏) , scrollbars (滚动条) ) 并没有在Firefox和Chrome 等现代浏览器中得到支持</p>
    <p>这些设置需要以逗号分隔的名值对形式出现，其中名值对以等号连接。(特性字符串中不能包含空格) 来看下面的列子</p>
    <code>
    <pre>
    window.open('http://www.wiley.com/',
      'wileywindow',
      "height=400,width=400,top=100,left=100,resizable=no");
    </pre>
  </code>
    <button id="openBtn">打开弹窗</button>
    <p>这里确实是禁止了拖动变换大小 , 但是浏览器限制的太严格了 , 所以没有办法了 只会打开一个可缩放的新窗口，大小为400像素x400像素，位于离屏幕左边及顶边各素的位置</p>
    <p>window.open()方法返回一个对新建窗口的引用。这个对象与普通 window 对象没有区别，只是为控制新窗口提供方便 例如,
      某些浏览器默认不允许缩放或移动主窗口，但可能允许缩放或移动通过window.open()创建的窗口。跟使用任何 window 对象一样，可以使用这个对象操纵新打开的窗口</p>
    <p>也就是窗口的限制 , 跟你打开的方式不同 , window.open的命名跟window是一样的可以用于更改页面的元素等等</p>
    <code>
    <pre>
    let wileyWin = window.open('http://www.mihoyo.com/',
      'mihoyo',
      "height=400,width=400,top=10,left=10,resizable=yes")

    // 缩放
    wileyWin.resizeTo(500, 500)

    // 移动
    wileyWin.moveTo(100, 100)

    <strong> 还可以使用close()方法关闭打开的窗口</strong>
    wileyWin.close()
    </pre>
  </code>
    <p>这个方法只能用于 window.open()创建的弹出窗口。虽然不可能不经用户确认就关闭主窗口,但弹出窗口可以调用 top.close()来关闭自己。关闭窗口以后，窗口的引用虽然还在，但只能用于检查其closed属性</p>
    <strong>人话就是 窗口是真正的关闭了 , 但是js中的引用还未被销毁是因为用于closed属性检测窗口是否关闭了 , 当然你也可以手动销毁</strong>
    <code>
    <pre>
    alert(wileyWin.closed)
    // true
    <strong>true 就是已经关闭 false表示还未关闭</strong>
    </pre>
  </code>
    <p>新创建窗口的 window 对象有一个opener 属性，指向打开它的窗口。这个属性只在弹出窗口的最上层window对象 (top) 有定义 , 是指向调用window.open() 打开他的窗口或者窗格的指针</p>
    <strong>说人话就是 旧窗口（源窗口） 通过 window.open() 打开 新窗口（弹出窗口） 时，新窗口的 opener 属性 会指向 旧窗口的 window 对象。 , 而且这个属性只有新窗口的全局window才有 ,
      像iframe的window是没有的</strong>
    <code>
    <pre>
    console.log(wileyWin.opener)
    // window

    console.log(wileyWin.opener === window)
    // true
    </pre>
  </code>
    <p>虽然新建窗口中有指向打开它的窗口的指针,但反之则不然。窗口不会跟踪记录自己打开的新窗口, 因此开发者需要自己记录。</p>
    <p class="retract">在某些浏览器中，每个标签页会运行在独立的进程中。如果一个标签页打开了另一个标签页，而window对象需要跟另一个标签页通信，则标签页就不能运行在独立的进程中。
      在这些浏览器中、可以将新打开的标签的opener属性设置为null , 表示新打开的标签页可以运行在独立的进程中 , 比如
    </p>
    <strong>人话就是 默认的情况下 A窗口和B窗口是可以相互操纵通信的 , 那这样他们之间就不是独立的进程 , 而将opener设置成null 就可以将两个页面在独立的进程中运行了</strong>
    <code>
    <pre>
    wileyWin.opener = null
    </pre>
  </code>
    <p>这里要注意了 此时的B进程(wileyWin)是不能操纵A进程的了(现在这个页面) 因为wileyWin.opener = null 隔断了 , 但是A进程可以通过wileyWin来修改页面的元素等等 , 核心是
      <strong>能操作但进程独立</strong>
    </p>
    <p>把opener设置为null表示新打开的标签页不需要与打开它的标签页通信，因此可以在独立的进程中运行。这个连接一旦切断，就无法恢复了</p>
  </section>
  <section>
    <h2>安全限制</h2>
    <p>弹出窗口有段时间被在线广告滥用。很多在线广告会把弹出窗口伪装成系统对话框,诱导用户点击。因为长得像系统对话框、所以用户很难分清这些弹窗的来源。为了让用户能够区分清楚，浏览器开始对弹窗施加限制。</p>
    <p class="retract">此外,浏览器仅在用户操作后才允许创建弹窗。在网页加载过程中调用window.open()没有效果, 而且还可能导致向用户显示错误。弹窗通常可能在点击鼠标或按下键盘中某个键的情况下才能打开。
    </p>
  </section>
  <section>
    <h2>弹窗屏蔽程序</h2>
    <p>所有现代浏览器都内置了屏蔽弹窗的程序,因此大多数意料之外的弹窗会被屏蔽。在浏览器屏蔽弹窗时, 可能会发生一些事。如果浏览器内置的弹窗屏蔽程序阻止了弹窗，那么
      window.open()很可能会返回nu11。此时，只要检查这个方法的返回值就可以知道弹窗是否被屏蔽了，比如:</p>
    <code>
      <pre>
    // 查看是否被屏蔽了
    if (wileyWin == null) {
      alert('The popup was blocked!')
    }
      </pre>
    </code>
    <p>在浏览器扩展或其他程序屏蔽弹窗时，window.open()通常会抛出错误。因此要准确检测弹窗是否被屏蔽，除了检测 window.open()的返回值，还要把它用try/catch 包装起来，像这样:</p>
    <code>
      <pre>
    try {
      let wileyWin = window.open('http://www.mihoyo.com/',
        'an',
        "height=400,width=400,top=10,left=10,resizable=yes")

      // 查看是否被屏蔽了
      if (wileyWin == null) {
        alert('The popup was blocked!')
      }
    } catch (ex) {
      blocked = true
    }

    if (blocked) {
      alert("The popup was blocked!")
    }
      </pre>
    </code>
    <p>无论弹窗是用什么方法屏蔽的,以上代码都可以准确判断调用 window.open()的弹窗是否被屏蔽了</p>
    <h3>注意</h3>
    <p>检查弹窗是否被屏蔽不影响浏览器显示关于弹窗被屏蔽的消息。</p>
  </section>
  <script>
    document.getElementById('openBtn').addEventListener('click', function () {
      window.open('http://www.wiley.com/',
        'wileywindow',
        "height=400,width=400,top=100,left=100,resizable=no");
    })

    let blocked = false

    try {
      let wileyWin = window.open('http://www.mihoyo.com/',
        'an',
        "height=400,width=400,top=10,left=10,resizable=yes")

      // 查看是否被屏蔽了
      if (wileyWin == null) {
        alert('The popup was blocked!')
      }
    } catch (ex) {
      blocked = true
    }

    if (blocked) {
      alert("The popup was blocked!")
    }


    let wileyWin = window.open('http://www.mihoyo.zzz.com/',
      'an',
      "height=400,width=400,top=10,left=10,resizable=yes")

    // 缩放
    wileyWin.resizeTo(500, 500)

    // 移动
    wileyWin.moveTo(100, 100)

    // 还可以使用close()方法关闭打开的窗口
    wileyWin.close()

    console.log(wileyWin.closed)// true

    console.log(wileyWin.opener)
    // window
    console.log(wileyWin.opener === window)

    wileyWin.opener = null
  </script>
</body>

</html>