<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="../../index.css">
</head>

<body>
  <h1>历史状态管理</h1>
  <p>现代web应用程序开发中最难的环节之一就是历史记录管理。用户每次点击都会触发页面刷新的时代早已过去 , “后退”和“前进”按钮对用户来说就代表“帮我切换一个状态”的历史也随之结束 。
    为解决这个问题,首先出现的是hashchange事件(第15章介绍事件时会讨论)。HTML5也为 history 对象增加了方便的状态管理特性
  </p>
  <p class="retract">hashchange 会在页面URL的散列变化时被触发 ,
    开发者可以在此时执行某些操作。而状态管理API则可以让开发者改变浏览器URL而不会加载新页面。为此，可以使用history.pushstate()方法。
    这个方法接收3个参数:一个state对象、一个新状态的标题和一个(可选的)相对URL。例如:
  </p>
  <code>
    <pre>
    
    let stateObject = { foo: 'bar' }
    history.pushState(stateObject, 'My title', 'ceshi.html')
    </pre>
  </code>
  <p><strong>此时的页面是不会刷新的 ,是正常的 ,但是url地址已经改变了</strong></p>
  <p>pushState()方法执行后，状态信息就会被推到历史记录中,浏览器地址栏也会改变以反映新的相对的URL。除了这些变化之外,即使 1ocation.href 返回的是地址栏中的内容，浏览器也不会向服务器
    发送请求。 第二个参数并未被当前实现所使用，因此既可以传人一个空字符串也可以传人一个短标题。第一个参数应该包含正确初始化页面状态所必需的信息。为防止滥用,这个状态的对象大小是有限制的通常在 500 KB~1 MB。
  </p>
  <strong>第一个参数就是用于记录当前页面的种种信息 , 比如在哪个位置 ,哪个页面 也就是(state) 会跟着历史记录存起来, 这个参数是根据实际开发场景的 , 第二个参数就是相当于 title ,
    但是浏览器为了安全会忽略掉</strong>
  <p>因为 pushstate()会创建新的历史记录，所以也会相应地启用“后退”按钮。此时单击“后退”按钮，就会触发 window对象上的popstate事件。popstate事件的事件对象有一个state属性,其
    中包含通过 pushstate()第一个参数传人的state对象:
  </p>
  <code>
    <pre>
    // 切换到页面2，并新增历史记录
    function goPage2() {
      document.getElementById('page1').style.display = 'none';
      document.getElementById('page2').style.display = 'block';
      history.pushState({ page: 'page2' }, '', 'page2.html');
    }

    // 监听popstate事件
    window.addEventListener('popstate', (ev) => {
      let state = ev.state;
      console.log('触发popstate了，state是：', state); // 这里的log
      if (state) {
        console.log(1);
        // processState(state); // 假设这里有恢复页面的逻辑
      }
    });
    </pre>
  </code>
  <p><strong>这里可以使用手动触发 , 或者是history.back() <i>重要的是一定要有历史记录</i></strong></p>
  <div id="page1">页面1</div>
  <div id="page2" style="display:none;">页面2</div>
  <button onclick="goPage2()">去页面2</button>
  <p>基于这个状态，应该把页面重置为状态对象所表示的状态(因为浏览器不会自动为你做这些)。记住，页面初次加载时没有状态。因此单击“后退”按钮直到返回最初页面时，event.state会为nu11
    <strong>浏览器只负责 回退到之前的页面 , 但是要回退他用户浏览器的地方得自己设置 ；而且最初的页面压根没状态，回退到这一步时要单独处理。</strong>
  </p>
  <p>可以通过 history.state 获取当前的状态对象，也可以使用replacestate()并传入与pushstate()同样的前两个参数来更新状态。更新状态不会创建新历史记录，只会覆盖当前状态:</p>
  <strong>replacestate()</strong>
  <ul>
    <li><strong>改历史记录:</strong>把当前正在看的这页记录（栈顶那条）直接 “覆盖重写” 了；不会创建新的</li>
    <li><strong>改 URL:</strong>地址栏会显示新的 URL，但页面不刷新；</li>
    <li><strong>不动当前页面内容:</strong>页面还是你现在看到的样子（DOM 不会自动变，需要自己写代码改）；</li>
    <li><strong>回退不到被覆盖的状态:</strong>因为原来的记录已经被新记录替掉了，点 “后退” 会跳到 “当前记录的上一条”（比如原来栈是 [A, B]，用 replaceState 把 B 换成 C，栈变成 [A,
      C]，后退就会回到 A，而不是原来的 B）</li>
  </ul>
  <code>
    <pre>
    history.replaceState({ newFoo: 'newBar' }, 'New title')
    </pre>
  </code>
  <p>传给 pushstate()和replacestate()的state 对象应该只包含可以被序列化的信息。因此 <strong>DOM 元素之类的对象并不适合放到状态对象里保存。</strong></p>
  <p><strong>注意</strong>使用HTMLS状态管理时，要确保通过pushstate()创建的每个“假”URL背后都对应着服务器上一个真实的物理 URL。否则，单击“刷新”按钮会导致 404错误。所有</p>
  单页应用程序(SPA，Single Page Application)框架都必须通过服务器或客户端的某些配置解决这个问题。
  <strong>前端负责 “假装” 有多个 URL，服务器负责 “配合演戏”，告诉浏览器 “这些 URL 其实都是同一个入口文件”</strong>
  <script>
    let stateObject = { foo: 'bar' }
    history.pushState(stateObject, 'My title', 'ceshi.html')

    // window.addEventListener('popstate', (ev) => {
    //   let state = ev.state
    //   console.log(state);
    //   if (state) { // 第一个页面加载时状态是nu11
    //     console.log(1);

    //     processState(state)
    //   }
    // })

    // 切换到页面2，并新增历史记录
    function goPage2() {
      document.getElementById('page1').style.display = 'none';
      document.getElementById('page2').style.display = 'block';
      history.pushState({ page: 'page2' }, '', 'page2.html');
    }

    // 监听popstate事件
    window.addEventListener('popstate', (ev) => {
      let state = ev.state;
      console.log('触发popstate了，state是：', state); // 这里的log
      if (state) {
        console.log(1);
        // processState(state); // 假设这里有恢复页面的逻辑
      }
    });

    history.replaceState({ newFoo: 'newBar' }, 'New title')
  </script>
</body>

</html>